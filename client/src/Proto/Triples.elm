module Proto.Triples exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: proto/triples.proto

import Protobuf exposing (..)

import Json.Decode as JD
import Json.Encode as JE


type ClaimType
    = Match -- 0
    | Nomatch -- 1


claimTypeDecoder : JD.Decoder ClaimType
claimTypeDecoder =
    let
        lookup s =
            case s of
                "MATCH" ->
                    Match

                "NOMATCH" ->
                    Nomatch

                _ ->
                    Match
    in
        JD.map lookup JD.string


claimTypeDefault : ClaimType
claimTypeDefault = Match


claimTypeEncoder : ClaimType -> JE.Value
claimTypeEncoder v =
    let
        lookup s =
            case s of
                Match ->
                    "MATCH"

                Nomatch ->
                    "NOMATCH"

    in
        JE.string <| lookup v


type alias Claim =
    { type_ : ClaimType -- 1
    , cards : List Int -- 2
    }


claimDecoder : JD.Decoder Claim
claimDecoder =
    JD.lazy <| \_ -> decode Claim
        |> required "type" claimTypeDecoder claimTypeDefault
        |> repeated "cards" JD.int


claimEncoder : Claim -> JE.Value
claimEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "type" claimTypeEncoder claimTypeDefault v.type_)
        , (repeatedFieldEncoder "cards" JE.int v.cards)
        ]


type alias Event =
    { eventOneof : EventOneof
    }


type EventOneof
    = EventOneofUnspecified
    | Join Event_Join
    | Claimed Event_Claimed


eventOneofDecoder : JD.Decoder EventOneof
eventOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Join (JD.field "join" event_JoinDecoder)
        , JD.map Claimed (JD.field "claimed" event_ClaimedDecoder)
        , JD.succeed EventOneofUnspecified
        ]


eventOneofEncoder : EventOneof -> Maybe ( String, JE.Value )
eventOneofEncoder v =
    case v of
        EventOneofUnspecified ->
            Nothing
        Join x ->
            Just ( "join", event_JoinEncoder x )
        Claimed x ->
            Just ( "claimed", event_ClaimedEncoder x )


eventDecoder : JD.Decoder Event
eventDecoder =
    JD.lazy <| \_ -> decode Event
        |> field eventOneofDecoder


eventEncoder : Event -> JE.Value
eventEncoder v =
    JE.object <| List.filterMap identity <|
        [ (eventOneofEncoder v.eventOneof)
        ]


type alias Event_Join =
    { name : String -- 1
    }


event_JoinDecoder : JD.Decoder Event_Join
event_JoinDecoder =
    JD.lazy <| \_ -> decode Event_Join
        |> required "name" JD.string ""


event_JoinEncoder : Event_Join -> JE.Value
event_JoinEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "name" JE.string "" v.name)
        ]


type alias Event_Claimed =
    { name : String -- 1
    , type_ : ClaimType -- 2
    , result : Event_Claimed_Result -- 3
    }


type Event_Claimed_Result
    = Event_Claimed_Correct -- 0
    | Event_Claimed_Wrong -- 1
    | Event_Claimed_Late -- 2


event_ClaimedDecoder : JD.Decoder Event_Claimed
event_ClaimedDecoder =
    JD.lazy <| \_ -> decode Event_Claimed
        |> required "name" JD.string ""
        |> required "type" claimTypeDecoder claimTypeDefault
        |> required "result" event_Claimed_ResultDecoder event_Claimed_ResultDefault


event_Claimed_ResultDecoder : JD.Decoder Event_Claimed_Result
event_Claimed_ResultDecoder =
    let
        lookup s =
            case s of
                "CORRECT" ->
                    Event_Claimed_Correct

                "WRONG" ->
                    Event_Claimed_Wrong

                "LATE" ->
                    Event_Claimed_Late

                _ ->
                    Event_Claimed_Correct
    in
        JD.map lookup JD.string


event_Claimed_ResultDefault : Event_Claimed_Result
event_Claimed_ResultDefault = Event_Claimed_Correct


event_ClaimedEncoder : Event_Claimed -> JE.Value
event_ClaimedEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "name" JE.string "" v.name)
        , (requiredFieldEncoder "type" claimTypeEncoder claimTypeDefault v.type_)
        , (requiredFieldEncoder "result" event_Claimed_ResultEncoder event_Claimed_ResultDefault v.result)
        ]


event_Claimed_ResultEncoder : Event_Claimed_Result -> JE.Value
event_Claimed_ResultEncoder v =
    let
        lookup s =
            case s of
                Event_Claimed_Correct ->
                    "CORRECT"

                Event_Claimed_Wrong ->
                    "WRONG"

                Event_Claimed_Late ->
                    "LATE"

    in
        JE.string <| lookup v


type alias Change =
    { changeOneof : ChangeOneof
    }


type ChangeOneof
    = ChangeOneofUnspecified
    | Deal Change_Deal
    | Match Change_Match
    | Move Change_Move


changeOneofDecoder : JD.Decoder ChangeOneof
changeOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Deal (JD.field "deal" change_DealDecoder)
        , JD.map Match (JD.field "match" change_MatchDecoder)
        , JD.map Move (JD.field "move" change_MoveDecoder)
        , JD.succeed ChangeOneofUnspecified
        ]


changeOneofEncoder : ChangeOneof -> Maybe ( String, JE.Value )
changeOneofEncoder v =
    case v of
        ChangeOneofUnspecified ->
            Nothing
        Deal x ->
            Just ( "deal", change_DealEncoder x )
        Match x ->
            Just ( "match", change_MatchEncoder x )
        Move x ->
            Just ( "move", change_MoveEncoder x )


changeDecoder : JD.Decoder Change
changeDecoder =
    JD.lazy <| \_ -> decode Change
        |> field changeOneofDecoder


changeEncoder : Change -> JE.Value
changeEncoder v =
    JE.object <| List.filterMap identity <|
        [ (changeOneofEncoder v.changeOneof)
        ]


type alias Change_Position =
    { x : Int -- 1
    , y : Int -- 2
    }


change_PositionDecoder : JD.Decoder Change_Position
change_PositionDecoder =
    JD.lazy <| \_ -> decode Change_Position
        |> required "x" JD.int 0
        |> required "y" JD.int 0


change_PositionEncoder : Change_Position -> JE.Value
change_PositionEncoder v =
    JE.object <| List.filterMap identity <|
        [ (requiredFieldEncoder "x" JE.int 0 v.x)
        , (requiredFieldEncoder "y" JE.int 0 v.y)
        ]


type alias Change_Deal =
    { places : List Change_Deal_Place -- 1
    }


change_DealDecoder : JD.Decoder Change_Deal
change_DealDecoder =
    JD.lazy <| \_ -> decode Change_Deal
        |> repeated "places" change_Deal_PlaceDecoder


change_DealEncoder : Change_Deal -> JE.Value
change_DealEncoder v =
    JE.object <| List.filterMap identity <|
        [ (repeatedFieldEncoder "places" change_Deal_PlaceEncoder v.places)
        ]


type alias Change_Deal_Place =
    { position : Maybe Change_Position -- 1
    , card : Int -- 2
    }


change_Deal_PlaceDecoder : JD.Decoder Change_Deal_Place
change_Deal_PlaceDecoder =
    JD.lazy <| \_ -> decode Change_Deal_Place
        |> optional "position" change_PositionDecoder
        |> required "card" JD.int 0


change_Deal_PlaceEncoder : Change_Deal_Place -> JE.Value
change_Deal_PlaceEncoder v =
    JE.object <| List.filterMap identity <|
        [ (optionalEncoder "position" change_PositionEncoder v.position)
        , (requiredFieldEncoder "card" JE.int 0 v.card)
        ]


type alias Change_Match =
    { positions : List Change_Position -- 1
    }


change_MatchDecoder : JD.Decoder Change_Match
change_MatchDecoder =
    JD.lazy <| \_ -> decode Change_Match
        |> repeated "positions" change_PositionDecoder


change_MatchEncoder : Change_Match -> JE.Value
change_MatchEncoder v =
    JE.object <| List.filterMap identity <|
        [ (repeatedFieldEncoder "positions" change_PositionEncoder v.positions)
        ]


type alias Change_Move =
    { moves : List Change_Move_MoveOne -- 1
    }


change_MoveDecoder : JD.Decoder Change_Move
change_MoveDecoder =
    JD.lazy <| \_ -> decode Change_Move
        |> repeated "moves" change_Move_MoveOneDecoder


change_MoveEncoder : Change_Move -> JE.Value
change_MoveEncoder v =
    JE.object <| List.filterMap identity <|
        [ (repeatedFieldEncoder "moves" change_Move_MoveOneEncoder v.moves)
        ]


type alias Change_Move_MoveOne =
    { from : Maybe Change_Position -- 1
    , to : Maybe Change_Position -- 2
    }


change_Move_MoveOneDecoder : JD.Decoder Change_Move_MoveOne
change_Move_MoveOneDecoder =
    JD.lazy <| \_ -> decode Change_Move_MoveOne
        |> optional "from" change_PositionDecoder
        |> optional "to" change_PositionDecoder


change_Move_MoveOneEncoder : Change_Move_MoveOne -> JE.Value
change_Move_MoveOneEncoder v =
    JE.object <| List.filterMap identity <|
        [ (optionalEncoder "from" change_PositionEncoder v.from)
        , (optionalEncoder "to" change_PositionEncoder v.to)
        ]


type alias Update =
    { updateOneof : UpdateOneof
    }


type UpdateOneof
    = UpdateOneofUnspecified
    | Change Change
    | Event Event


updateOneofDecoder : JD.Decoder UpdateOneof
updateOneofDecoder =
    JD.lazy <| \_ -> JD.oneOf
        [ JD.map Change (JD.field "change" changeDecoder)
        , JD.map Event (JD.field "event" eventDecoder)
        , JD.succeed UpdateOneofUnspecified
        ]


updateOneofEncoder : UpdateOneof -> Maybe ( String, JE.Value )
updateOneofEncoder v =
    case v of
        UpdateOneofUnspecified ->
            Nothing
        Change x ->
            Just ( "change", changeEncoder x )
        Event x ->
            Just ( "event", eventEncoder x )


updateDecoder : JD.Decoder Update
updateDecoder =
    JD.lazy <| \_ -> decode Update
        |> field updateOneofDecoder


updateEncoder : Update -> JE.Value
updateEncoder v =
    JE.object <| List.filterMap identity <|
        [ (updateOneofEncoder v.updateOneof)
        ]
