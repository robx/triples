module Proto.Triples exposing (..)

-- DO NOT EDIT
-- AUTOGENERATED BY THE ELM PROTOCOL BUFFER COMPILER
-- https://github.com/tiziano88/elm-protobuf
-- source file: proto/triples.proto

import Json.Decode as JD
import Json.Encode as JE
import Protobuf exposing (..)


type ClaimType
    = ClaimMatch -- 0
    | ClaimNomatch -- 1


claimTypeDecoder : JD.Decoder ClaimType
claimTypeDecoder =
    let
        lookup s =
            case s of
                "CLAIM_MATCH" ->
                    ClaimMatch

                "CLAIM_NOMATCH" ->
                    ClaimNomatch

                _ ->
                    ClaimMatch
    in
    JD.map lookup JD.string


claimTypeDefault : ClaimType
claimTypeDefault =
    ClaimMatch


claimTypeEncoder : ClaimType -> JE.Value
claimTypeEncoder v =
    let
        lookup s =
            case s of
                ClaimMatch ->
                    "CLAIM_MATCH"

                ClaimNomatch ->
                    "CLAIM_NOMATCH"
    in
    JE.string <| lookup v


type alias Claim =
    { type_ : ClaimType -- 1
    , cards : List Int -- 2
    }


claimDecoder : JD.Decoder Claim
claimDecoder =
    JD.lazy <|
        \_ ->
            decode Claim
                |> required "type" claimTypeDecoder claimTypeDefault
                |> repeated "cards" JD.int


claimEncoder : Claim -> JE.Value
claimEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "type" claimTypeEncoder claimTypeDefault v.type_
            , repeatedFieldEncoder "cards" JE.int v.cards
            ]


type alias Score =
    { match : Int -- 1
    , matchwrong : Int -- 2
    , nomatch : Int -- 3
    , nomatchwrong : Int -- 4
    }


scoreDecoder : JD.Decoder Score
scoreDecoder =
    JD.lazy <|
        \_ ->
            decode Score
                |> required "match" JD.int 0
                |> required "matchwrong" JD.int 0
                |> required "nomatch" JD.int 0
                |> required "nomatchwrong" JD.int 0


scoreEncoder : Score -> JE.Value
scoreEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "match" JE.int 0 v.match
            , requiredFieldEncoder "matchwrong" JE.int 0 v.matchwrong
            , requiredFieldEncoder "nomatch" JE.int 0 v.nomatch
            , requiredFieldEncoder "nomatchwrong" JE.int 0 v.nomatchwrong
            ]


type alias UpdateEvent =
    { eventOneof : EventOneof
    }


type EventOneof
    = EventOneofUnspecified
    | Join UpdateEvent_EventJoin
    | Leave UpdateEvent_EventLeave
    | Claimed UpdateEvent_EventClaimed


eventOneofDecoder : JD.Decoder EventOneof
eventOneofDecoder =
    JD.lazy <|
        \_ ->
            JD.oneOf
                [ JD.map Join (JD.field "join" updateEvent_EventJoinDecoder)
                , JD.map Leave (JD.field "leave" updateEvent_EventLeaveDecoder)
                , JD.map Claimed (JD.field "claimed" updateEvent_EventClaimedDecoder)
                , JD.succeed EventOneofUnspecified
                ]


eventOneofEncoder : EventOneof -> Maybe ( String, JE.Value )
eventOneofEncoder v =
    case v of
        EventOneofUnspecified ->
            Nothing

        Join x ->
            Just ( "join", updateEvent_EventJoinEncoder x )

        Leave x ->
            Just ( "leave", updateEvent_EventLeaveEncoder x )

        Claimed x ->
            Just ( "claimed", updateEvent_EventClaimedEncoder x )


updateEventDecoder : JD.Decoder UpdateEvent
updateEventDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateEvent
                |> field eventOneofDecoder


updateEventEncoder : UpdateEvent -> JE.Value
updateEventEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ eventOneofEncoder v.eventOneof
            ]


type alias UpdateEvent_EventJoin =
    { name : String -- 1
    }


updateEvent_EventJoinDecoder : JD.Decoder UpdateEvent_EventJoin
updateEvent_EventJoinDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateEvent_EventJoin
                |> required "name" JD.string ""


updateEvent_EventJoinEncoder : UpdateEvent_EventJoin -> JE.Value
updateEvent_EventJoinEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "name" JE.string "" v.name
            ]


type alias UpdateEvent_EventLeave =
    { name : String -- 1
    }


updateEvent_EventLeaveDecoder : JD.Decoder UpdateEvent_EventLeave
updateEvent_EventLeaveDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateEvent_EventLeave
                |> required "name" JD.string ""


updateEvent_EventLeaveEncoder : UpdateEvent_EventLeave -> JE.Value
updateEvent_EventLeaveEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "name" JE.string "" v.name
            ]


type alias UpdateEvent_EventClaimed =
    { name : String -- 1
    , type_ : ClaimType -- 2
    , result : UpdateEvent_EventClaimed_Result -- 3
    , score : Maybe Score -- 4
    }


type UpdateEvent_EventClaimed_Result
    = UpdateEvent_EventClaimed_Correct -- 0
    | UpdateEvent_EventClaimed_Wrong -- 1
    | UpdateEvent_EventClaimed_Late -- 2


updateEvent_EventClaimedDecoder : JD.Decoder UpdateEvent_EventClaimed
updateEvent_EventClaimedDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateEvent_EventClaimed
                |> required "name" JD.string ""
                |> required "type" claimTypeDecoder claimTypeDefault
                |> required "result" updateEvent_EventClaimed_ResultDecoder updateEvent_EventClaimed_ResultDefault
                |> optional "score" scoreDecoder


updateEvent_EventClaimed_ResultDecoder : JD.Decoder UpdateEvent_EventClaimed_Result
updateEvent_EventClaimed_ResultDecoder =
    let
        lookup s =
            case s of
                "CORRECT" ->
                    UpdateEvent_EventClaimed_Correct

                "WRONG" ->
                    UpdateEvent_EventClaimed_Wrong

                "LATE" ->
                    UpdateEvent_EventClaimed_Late

                _ ->
                    UpdateEvent_EventClaimed_Correct
    in
    JD.map lookup JD.string


updateEvent_EventClaimed_ResultDefault : UpdateEvent_EventClaimed_Result
updateEvent_EventClaimed_ResultDefault =
    UpdateEvent_EventClaimed_Correct


updateEvent_EventClaimedEncoder : UpdateEvent_EventClaimed -> JE.Value
updateEvent_EventClaimedEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "name" JE.string "" v.name
            , requiredFieldEncoder "type" claimTypeEncoder claimTypeDefault v.type_
            , requiredFieldEncoder "result" updateEvent_EventClaimed_ResultEncoder updateEvent_EventClaimed_ResultDefault v.result
            , optionalEncoder "score" scoreEncoder v.score
            ]


updateEvent_EventClaimed_ResultEncoder : UpdateEvent_EventClaimed_Result -> JE.Value
updateEvent_EventClaimed_ResultEncoder v =
    let
        lookup s =
            case s of
                UpdateEvent_EventClaimed_Correct ->
                    "CORRECT"

                UpdateEvent_EventClaimed_Wrong ->
                    "WRONG"

                UpdateEvent_EventClaimed_Late ->
                    "LATE"
    in
    JE.string <| lookup v


type alias Position =
    { x : Int -- 1
    , y : Int -- 2
    }


positionDecoder : JD.Decoder Position
positionDecoder =
    JD.lazy <|
        \_ ->
            decode Position
                |> required "x" JD.int 0
                |> required "y" JD.int 0


positionEncoder : Position -> JE.Value
positionEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "x" JE.int 0 v.x
            , requiredFieldEncoder "y" JE.int 0 v.y
            ]


type alias PlacedCard =
    { position : Maybe Position -- 1
    , card : Int -- 2
    }


placedCardDecoder : JD.Decoder PlacedCard
placedCardDecoder =
    JD.lazy <|
        \_ ->
            decode PlacedCard
                |> optional "position" positionDecoder
                |> required "card" JD.int 0


placedCardEncoder : PlacedCard -> JE.Value
placedCardEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ optionalEncoder "position" positionEncoder v.position
            , requiredFieldEncoder "card" JE.int 0 v.card
            ]


type alias UpdateChange =
    { changeOneof : ChangeOneof
    }


type ChangeOneof
    = ChangeOneofUnspecified
    | Deal UpdateChange_ChangeDeal
    | Match UpdateChange_ChangeMatch
    | Move UpdateChange_ChangeMove


changeOneofDecoder : JD.Decoder ChangeOneof
changeOneofDecoder =
    JD.lazy <|
        \_ ->
            JD.oneOf
                [ JD.map Deal (JD.field "deal" updateChange_ChangeDealDecoder)
                , JD.map Match (JD.field "match" updateChange_ChangeMatchDecoder)
                , JD.map Move (JD.field "move" updateChange_ChangeMoveDecoder)
                , JD.succeed ChangeOneofUnspecified
                ]


changeOneofEncoder : ChangeOneof -> Maybe ( String, JE.Value )
changeOneofEncoder v =
    case v of
        ChangeOneofUnspecified ->
            Nothing

        Deal x ->
            Just ( "deal", updateChange_ChangeDealEncoder x )

        Match x ->
            Just ( "match", updateChange_ChangeMatchEncoder x )

        Move x ->
            Just ( "move", updateChange_ChangeMoveEncoder x )


updateChangeDecoder : JD.Decoder UpdateChange
updateChangeDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateChange
                |> field changeOneofDecoder


updateChangeEncoder : UpdateChange -> JE.Value
updateChangeEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ changeOneofEncoder v.changeOneof
            ]


type alias UpdateChange_ChangeDeal =
    { cards : List PlacedCard -- 1
    }


updateChange_ChangeDealDecoder : JD.Decoder UpdateChange_ChangeDeal
updateChange_ChangeDealDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateChange_ChangeDeal
                |> repeated "cards" placedCardDecoder


updateChange_ChangeDealEncoder : UpdateChange_ChangeDeal -> JE.Value
updateChange_ChangeDealEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ repeatedFieldEncoder "cards" placedCardEncoder v.cards
            ]


type alias UpdateChange_ChangeMatch =
    { positions : List Position -- 1
    }


updateChange_ChangeMatchDecoder : JD.Decoder UpdateChange_ChangeMatch
updateChange_ChangeMatchDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateChange_ChangeMatch
                |> repeated "positions" positionDecoder


updateChange_ChangeMatchEncoder : UpdateChange_ChangeMatch -> JE.Value
updateChange_ChangeMatchEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ repeatedFieldEncoder "positions" positionEncoder v.positions
            ]


type alias UpdateChange_ChangeMove =
    { moves : List UpdateChange_ChangeMove_MoveOne -- 1
    }


updateChange_ChangeMoveDecoder : JD.Decoder UpdateChange_ChangeMove
updateChange_ChangeMoveDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateChange_ChangeMove
                |> repeated "moves" updateChange_ChangeMove_MoveOneDecoder


updateChange_ChangeMoveEncoder : UpdateChange_ChangeMove -> JE.Value
updateChange_ChangeMoveEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ repeatedFieldEncoder "moves" updateChange_ChangeMove_MoveOneEncoder v.moves
            ]


type alias UpdateChange_ChangeMove_MoveOne =
    { from : Maybe Position -- 1
    , to : Maybe Position -- 2
    }


updateChange_ChangeMove_MoveOneDecoder : JD.Decoder UpdateChange_ChangeMove_MoveOne
updateChange_ChangeMove_MoveOneDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateChange_ChangeMove_MoveOne
                |> optional "from" positionDecoder
                |> optional "to" positionDecoder


updateChange_ChangeMove_MoveOneEncoder : UpdateChange_ChangeMove_MoveOne -> JE.Value
updateChange_ChangeMove_MoveOneEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ optionalEncoder "from" positionEncoder v.from
            , optionalEncoder "to" positionEncoder v.to
            ]


type alias UpdateFull =
    { cards : List PlacedCard -- 1
    , deckSize : Int -- 2
    , scores : List UpdateFull_PlayerScore -- 3
    , matchSize : Int -- 4
    , cols : Int -- 5
    , rows : Int -- 6
    }


updateFullDecoder : JD.Decoder UpdateFull
updateFullDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateFull
                |> repeated "cards" placedCardDecoder
                |> required "deckSize" JD.int 0
                |> repeated "scores" updateFull_PlayerScoreDecoder
                |> required "matchSize" JD.int 0
                |> required "cols" JD.int 0
                |> required "rows" JD.int 0


updateFullEncoder : UpdateFull -> JE.Value
updateFullEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ repeatedFieldEncoder "cards" placedCardEncoder v.cards
            , requiredFieldEncoder "deckSize" JE.int 0 v.deckSize
            , repeatedFieldEncoder "scores" updateFull_PlayerScoreEncoder v.scores
            , requiredFieldEncoder "matchSize" JE.int 0 v.matchSize
            , requiredFieldEncoder "cols" JE.int 0 v.cols
            , requiredFieldEncoder "rows" JE.int 0 v.rows
            ]


type alias UpdateFull_PlayerScore =
    { name : String -- 1
    , score : Maybe Score -- 2
    }


updateFull_PlayerScoreDecoder : JD.Decoder UpdateFull_PlayerScore
updateFull_PlayerScoreDecoder =
    JD.lazy <|
        \_ ->
            decode UpdateFull_PlayerScore
                |> required "name" JD.string ""
                |> optional "score" scoreDecoder


updateFull_PlayerScoreEncoder : UpdateFull_PlayerScore -> JE.Value
updateFull_PlayerScoreEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ requiredFieldEncoder "name" JE.string "" v.name
            , optionalEncoder "score" scoreEncoder v.score
            ]


type alias Update =
    { updateOneof : UpdateOneof
    }


type UpdateOneof
    = UpdateOneofUnspecified
    | Change UpdateChange
    | Event UpdateEvent
    | Full UpdateFull


updateOneofDecoder : JD.Decoder UpdateOneof
updateOneofDecoder =
    JD.lazy <|
        \_ ->
            JD.oneOf
                [ JD.map Change (JD.field "change" updateChangeDecoder)
                , JD.map Event (JD.field "event" updateEventDecoder)
                , JD.map Full (JD.field "full" updateFullDecoder)
                , JD.succeed UpdateOneofUnspecified
                ]


updateOneofEncoder : UpdateOneof -> Maybe ( String, JE.Value )
updateOneofEncoder v =
    case v of
        UpdateOneofUnspecified ->
            Nothing

        Change x ->
            Just ( "change", updateChangeEncoder x )

        Event x ->
            Just ( "event", updateEventEncoder x )

        Full x ->
            Just ( "full", updateFullEncoder x )


updateDecoder : JD.Decoder Update
updateDecoder =
    JD.lazy <|
        \_ ->
            decode Update
                |> field updateOneofDecoder


updateEncoder : Update -> JE.Value
updateEncoder v =
    JE.object <|
        List.filterMap identity <|
            [ updateOneofEncoder v.updateOneof
            ]
